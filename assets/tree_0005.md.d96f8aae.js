import{_ as n,o as a,c as p,Q as l}from"./chunks/framework.91000686.js";const o="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARIAAAAfCAYAAAAr3kJJAAAAAXNSR0IArs4c6QAADMJJREFUeAHtnAeMVUUUhg+9dxApUpZeFBSIdAE1NCkJxEAIsICEToIUiRCQJkUIAREUlKJIRwGVntB7VzpSVIoivQsK7jdmXmbvvnJfW3ZxTrL7bpk7M+efM2dOmXtTzJ8///SNGzdixJJFwCJgEQgBgYwZM95PzXNvvvmm5M+fP4Qqku8jccpTNm3aJM2aNUu+TMT1/Msvv5S2bdtKihQpki0f33//vVSrVk1y5cqVbHnYvn275MmTR0qUKJFseQil43fu3JFVq1ZJylAets9YBCwCFgETAatITDTssUXAIhASAlaRhASbfcgiYBEwEbCKxETDHlsELAIhIWAVSUiw2YcsAhYBEwGrSEw07LFFwCIQEgJWkYQEm33IImARMBEIWpG89957snz5crMOv8dxG95k+PDhfstwc9++fbJkyRJPuXnz5smIESM8574OfvzxR+nbt6+cP3/eV5Gwrj948ECuXr0qjx8/jlfPo0eP1HXu+fr7559/4j2T1E7Yg/Lhhx8mtW4l6I8eA43z3bt3E5RhP4O+7+2XfUPJnY4ePapk/dy5c35ZuXLlisycOVOuXbumyh05csTVcxTu16+f/PDDD37r93ZTbUjzdsPXtVOnTknJkiV93U5w/ffff5ezZ88muO68QOcPHTokTZs2lbRp04rb527fvi30CWGLBq1du1Y+//xz+eKLL9SGI93G7t27ZezYsfrU6++ECROS9AYltxg7mXvy5InCO0OGDM5bUTnXY2BWniVLFqlfv760bt1a0qRJI1OnTpWtW7eaReIdP/fcc2oc411MZicoUGT9/v37fnvO4rps2TI1T2vWrCkoWZ7766+//D7HzZMnT8qLL74YsJyzQNCKxFlBpM779++vGEaJJAcqW7asDB061NPVKVOmSI4cOaRNmzaea8/ibmFWuz59+kjHjh2lbt26Hl4T4wDLM3v27HLx4kXZsWOHsmCZHJ07d5aWLVvK66+/rrpx6dIlmT59utq1XLFiRXUtXbp0idHFJNFGvXr11AL2wgsvJFp/kowiYXVLrBUuEuiiNCpVquSpCkHNmjVrvGuem8/QARP35s2bT4UjlDfb0CtUqKCskXfeeUe95oAiiYmJ8fRJW8CFCxd+5sfD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",s="/data_structure/assets/image-20231130104837172.49711800.png",T=JSON.parse('{"title":"线索二叉树","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"tree/0005.md","filePath":"tree/0005.md"}'),e={name:"tree/0005.md"},c=l('<h1 id="线索二叉树" tabindex="-1">线索二叉树 <a class="header-anchor" href="#线索二叉树" aria-label="Permalink to &quot;线索二叉树&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>叶子节点指向问题</p></div><p>二叉链拥有左子树指针,右子树指针和左标志和右标志</p><p><img src="'+o+`" alt="img"></p><p>如果结点有左子树，则<code>lchild</code>指针域指向左孩子(此时<code>LTag = 0</code> )，否则<code>lchild</code>指针域指向该结点的直接前趋(此时<code>LTag = 1</code> )。</p><p>如果结点有右子树，则 <code>rchild </code>指针域指向右孩子(此时<code>RTag = 0</code> )，否则 <code>rchild </code>指针域指向该结点的直接后继(此时<code>RTag = 1</code> )。</p><h2 id="结构定义" tabindex="-1">结构定义 <a class="header-anchor" href="#结构定义" aria-label="Permalink to &quot;结构定义&quot;">​</a></h2><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 线索二叉树结点类型标记 */</span></span>
<span class="line"><span style="color:#F97583;">typedef</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">enum</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Link, Thread</span><span style="color:#6A737D;">    // Link==0：指针(孩子)；Thread==1：线索</span></span>
<span class="line"><span style="color:#E1E4E8;">} PointerTag;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 线索二叉树元素类型定义，这里假设其元素类型为char */</span></span>
<span class="line"><span style="color:#F97583;">typedef</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> TElemType;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 线索二叉树结点定义 */</span></span>
<span class="line"><span style="color:#F97583;">typedef</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> BiThrNode{</span></span>
<span class="line"><span style="color:#E1E4E8;">    TElemType data;</span><span style="color:#6A737D;">            // 结点元素</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> BiThrNode</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> lchild;</span><span style="color:#6A737D;">  // 左孩子指针</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> BiThrNode</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> rchild;</span><span style="color:#6A737D;">  // 右孩子指针</span></span>
<span class="line"><span style="color:#E1E4E8;">    PointerTag LTag;</span><span style="color:#6A737D;">           // 左孩子标记</span></span>
<span class="line"><span style="color:#E1E4E8;">    PointerTag RTag;</span><span style="color:#6A737D;">           // 右孩子标记</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> BiThrNode</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> parent;</span><span style="color:#6A737D;">  // 双亲结点指针，仅在非递归遍历后序后继线索二叉树时使用</span></span>
<span class="line"><span style="color:#E1E4E8;">} BiThrNode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 指向线索二叉树结点的指针 */</span></span>
<span class="line"><span style="color:#F97583;">typedef</span><span style="color:#E1E4E8;"> BiThrNode</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> BiThrTree;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 全局变量 */</span></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> BiThrTree pre;</span><span style="color:#6A737D;">   // 指向当前访问结点的上一个结点(前驱)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 线索二叉树结点类型标记 */</span></span>
<span class="line"><span style="color:#D73A49;">typedef</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">enum</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    Link, Thread</span><span style="color:#6A737D;">    // Link==0：指针(孩子)；Thread==1：线索</span></span>
<span class="line"><span style="color:#24292E;">} PointerTag;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 线索二叉树元素类型定义，这里假设其元素类型为char */</span></span>
<span class="line"><span style="color:#D73A49;">typedef</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> TElemType;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 线索二叉树结点定义 */</span></span>
<span class="line"><span style="color:#D73A49;">typedef</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> BiThrNode{</span></span>
<span class="line"><span style="color:#24292E;">    TElemType data;</span><span style="color:#6A737D;">            // 结点元素</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> BiThrNode</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> lchild;</span><span style="color:#6A737D;">  // 左孩子指针</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> BiThrNode</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> rchild;</span><span style="color:#6A737D;">  // 右孩子指针</span></span>
<span class="line"><span style="color:#24292E;">    PointerTag LTag;</span><span style="color:#6A737D;">           // 左孩子标记</span></span>
<span class="line"><span style="color:#24292E;">    PointerTag RTag;</span><span style="color:#6A737D;">           // 右孩子标记</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> BiThrNode</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> parent;</span><span style="color:#6A737D;">  // 双亲结点指针，仅在非递归遍历后序后继线索二叉树时使用</span></span>
<span class="line"><span style="color:#24292E;">} BiThrNode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 指向线索二叉树结点的指针 */</span></span>
<span class="line"><span style="color:#D73A49;">typedef</span><span style="color:#24292E;"> BiThrNode</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> BiThrTree;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 全局变量 */</span></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> BiThrTree pre;</span><span style="color:#6A737D;">   // 指向当前访问结点的上一个结点(前驱)</span></span></code></pre></div><h2 id="创建二叉树" tabindex="-1">创建二叉树 <a class="header-anchor" href="#创建二叉树" aria-label="Permalink to &quot;创建二叉树&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>与二叉树-二叉链存储结构相同</p></div><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 创建二叉树的内部函数</span></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CreateTree</span><span style="color:#E1E4E8;">(BiThrTree</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">T</span><span style="color:#E1E4E8;">,FILE </span><span style="color:#F97583;">*</span><span style="color:#FFAB70;">fp</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> ch;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 读取当前结点的值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(fp </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">NULL</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">scanf</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#79B8FF;">%c</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">ch);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">ReadData</span><span style="color:#E1E4E8;">(fp, </span><span style="color:#9ECBFF;">&quot;</span><span style="color:#79B8FF;">%c</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">ch);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(ch </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;^&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">T </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">NULL</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 生成根结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">T </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (BiThrTree) </span><span style="color:#B392F0;">malloc</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">sizeof</span><span style="color:#E1E4E8;">(BiThrNode));</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">T)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">exit</span><span style="color:#E1E4E8;">(OVERFLOW);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        (</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">T)-&gt;data </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ch;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">CreateTree</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">((</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">T)-&gt;lchild), fp);</span><span style="color:#6A737D;"> // 创建左子树</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">CreateTree</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">((</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">T)-&gt;rchild), fp);</span><span style="color:#6A737D;"> // 创建右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> * 按照预设的定义来创建二叉树。</span></span>
<span class="line"><span style="color:#6A737D;"> * 这里约定使用【先序序列】来创建二叉树。</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#E1E4E8;">Status </span><span style="color:#B392F0;">CreateBiTree</span><span style="color:#E1E4E8;">(BiThrTree</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">T</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">char*</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">path</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    FILE</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> fp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> readFromConsole;</span><span style="color:#6A737D;">    // 是否从控制台读取数据</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果没有文件路径信息，则从控制台读取输入</span></span>
<span class="line"><span style="color:#E1E4E8;">    readFromConsole </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> path </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">NULL</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">strcmp</span><span style="color:#E1E4E8;">(path, </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(readFromConsole) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">printf</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;请输入二叉树的先序序列，如果没有子结点，使用^代替：&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">CreateTree</span><span style="color:#E1E4E8;">(T, </span><span style="color:#79B8FF;">NULL</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 打开文件，准备读取测试数据</span></span>
<span class="line"><span style="color:#E1E4E8;">        fp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fopen</span><span style="color:#E1E4E8;">(path, </span><span style="color:#9ECBFF;">&quot;r&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(fp </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">NULL</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ERROR;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">CreateTree</span><span style="color:#E1E4E8;">(T, fp);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">fclose</span><span style="color:#E1E4E8;">(fp);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> OK;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 创建二叉树的内部函数</span></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CreateTree</span><span style="color:#24292E;">(BiThrTree</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#E36209;">T</span><span style="color:#24292E;">,FILE </span><span style="color:#D73A49;">*</span><span style="color:#E36209;">fp</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> ch;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 读取当前结点的值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(fp </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">NULL</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">scanf</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;</span><span style="color:#005CC5;">%c</span><span style="color:#032F62;">&quot;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">ch);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">ReadData</span><span style="color:#24292E;">(fp, </span><span style="color:#032F62;">&quot;</span><span style="color:#005CC5;">%c</span><span style="color:#032F62;">&quot;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">ch);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(ch </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;^&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">T </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">NULL</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 生成根结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">T </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (BiThrTree) </span><span style="color:#6F42C1;">malloc</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">sizeof</span><span style="color:#24292E;">(BiThrNode));</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">T)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">exit</span><span style="color:#24292E;">(OVERFLOW);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        (</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">T)-&gt;data </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ch;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">CreateTree</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">((</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">T)-&gt;lchild), fp);</span><span style="color:#6A737D;"> // 创建左子树</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">CreateTree</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">((</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">T)-&gt;rchild), fp);</span><span style="color:#6A737D;"> // 创建右子树</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> * 按照预设的定义来创建二叉树。</span></span>
<span class="line"><span style="color:#6A737D;"> * 这里约定使用【先序序列】来创建二叉树。</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#24292E;">Status </span><span style="color:#6F42C1;">CreateBiTree</span><span style="color:#24292E;">(BiThrTree</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#E36209;">T</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">char*</span><span style="color:#24292E;"> </span><span style="color:#E36209;">path</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    FILE</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> fp;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> readFromConsole;</span><span style="color:#6A737D;">    // 是否从控制台读取数据</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果没有文件路径信息，则从控制台读取输入</span></span>
<span class="line"><span style="color:#24292E;">    readFromConsole </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> path </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">NULL</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">strcmp</span><span style="color:#24292E;">(path, </span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(readFromConsole) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">printf</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;请输入二叉树的先序序列，如果没有子结点，使用^代替：&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">CreateTree</span><span style="color:#24292E;">(T, </span><span style="color:#005CC5;">NULL</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 打开文件，准备读取测试数据</span></span>
<span class="line"><span style="color:#24292E;">        fp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fopen</span><span style="color:#24292E;">(path, </span><span style="color:#032F62;">&quot;r&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(fp </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">NULL</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ERROR;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">CreateTree</span><span style="color:#24292E;">(T, fp);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">fclose</span><span style="color:#24292E;">(fp);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> OK;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="中序全线索化二叉树" tabindex="-1">中序全线索化二叉树 <a class="header-anchor" href="#中序全线索化二叉树" aria-label="Permalink to &quot;中序全线索化二叉树&quot;">​</a></h2><p><img src="`+s+`" alt="image-20231130104837172"></p><p><code>thrt</code> 是扩展的节点，左指针指向根节点，右指针指向最后一个节点。</p><p><strong>当前结点没有左子树</strong>：对于结点<code>b</code>,结点<code>b</code>的左子树为空；此时的前驱为<code>+</code>，因此<code>a</code>的左指针指向<code>+</code></p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 如果当前结点的左子树为空，则需要建立前驱线索</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;">lchild){</span></span>
<span class="line"><span style="color:#E1E4E8;">    p-&gt;LTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread;</span></span>
<span class="line"><span style="color:#E1E4E8;">    p-&gt;lchild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pre;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 如果当前结点的左子树为空，则需要建立前驱线索</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">p</span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;">lchild){</span></span>
<span class="line"><span style="color:#24292E;">    p-&gt;LTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread;</span></span>
<span class="line"><span style="color:#24292E;">    p-&gt;lchild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pre;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>前驱没有后继</strong>：对于结点<code>+</code>，此时前驱<code>pre</code>为<code>a</code>。前驱<code>a</code>的右子树为空，因此<code>a</code>右子树指针指向<code>+</code></p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 如果前驱结点的右子树为空，则为前驱建立后继线索</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">pre</span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;">rchild){</span></span>
<span class="line"><span style="color:#E1E4E8;">    pre-&gt;RTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread;</span></span>
<span class="line"><span style="color:#E1E4E8;">    pre-&gt;rchild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 如果前驱结点的右子树为空，则为前驱建立后继线索</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">pre</span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;">rchild){</span></span>
<span class="line"><span style="color:#24292E;">    pre-&gt;RTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread;</span></span>
<span class="line"><span style="color:#24292E;">    pre-&gt;rchild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>完整代码</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 全局变量 */</span></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> BiThrTree pre;</span><span style="color:#6A737D;">   // 指向当前访问结点的上一个结点(前驱)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> * 中序全线索化的内部实现</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InTheading</span><span style="color:#E1E4E8;">(BiThrTree </span><span style="color:#FFAB70;">p</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(p </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">NULL</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 线索化左子树</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">InTheading</span><span style="color:#E1E4E8;">(p-&gt;lchild);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果当前结点的左子树为空，则需要建立前驱线索</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">p-&gt;lchild){</span></span>
<span class="line"><span style="color:#E1E4E8;">        p-&gt;LTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread;</span></span>
<span class="line"><span style="color:#E1E4E8;">        p-&gt;lchild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pre;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果左子树不为空</span></span>
<span class="line"><span style="color:#E1E4E8;">        p-&gt;LTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Link;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果前驱结点的右子树为空，则为前驱建立后继线索</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">pre-&gt;rchild){</span></span>
<span class="line"><span style="color:#E1E4E8;">        pre-&gt;RTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread;</span></span>
<span class="line"><span style="color:#E1E4E8;">        pre-&gt;rchild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">        pre-&gt;RTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Link;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;</span><span style="color:#6A737D;">   // pre向前挪一步</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">InTheading</span><span style="color:#E1E4E8;">(p-&gt;rchild);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> * 中序遍历二叉树T，并将其全线索化为线索二叉树Thrt。</span></span>
<span class="line"><span style="color:#6A737D;"> * 注：这里的线索包括前驱线索与后继线索。</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#E1E4E8;">Status </span><span style="color:#B392F0;">InOrderThreading</span><span style="color:#E1E4E8;">(BiThrTree</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">Thrt</span><span style="color:#E1E4E8;">, BiThrTree </span><span style="color:#FFAB70;">T</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 建立头结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (BiThrTree) </span><span style="color:#B392F0;">malloc</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">sizeof</span><span style="color:#E1E4E8;">(BiThrNode));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">!*</span><span style="color:#E1E4E8;">Thrt) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">exit</span><span style="color:#E1E4E8;">(OVERFLOW);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt)-&gt;data </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;</span><span style="color:#79B8FF;">\\0</span><span style="color:#9ECBFF;">&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt)-&gt;LTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Link;</span><span style="color:#6A737D;">       // 左孩子，需要指向二叉树的根结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt)-&gt;RTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread;</span><span style="color:#6A737D;">     // 右指针，需要指向中序序列最后一个元素，以便逆中序遍历线索二叉树</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt)-&gt;rchild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若二叉树为空，则左指针回指</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">T) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        (</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt)-&gt;lchild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        (</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt)-&gt;lchild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> T;</span><span style="color:#6A737D;">    // 指向二叉树头结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt;</span><span style="color:#6A737D;">            // 记录前驱信息，初始化为线索二叉树头结点</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">InTheading</span><span style="color:#E1E4E8;">(T);</span><span style="color:#6A737D;">          // 中序遍历，以进行中序线索化</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        pre-&gt;rchild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt;</span><span style="color:#6A737D;">    // 最后一个结点指回线索二叉树头结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        pre-&gt;RTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread;</span><span style="color:#6A737D;">     // 最后一个结点线索化</span></span>
<span class="line"><span style="color:#E1E4E8;">        (</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Thrt)-&gt;rchild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pre;</span><span style="color:#6A737D;">  // 头结点指向最后一个结点，建立双向联系</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> OK;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 全局变量 */</span></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> BiThrTree pre;</span><span style="color:#6A737D;">   // 指向当前访问结点的上一个结点(前驱)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> * 中序全线索化的内部实现</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InTheading</span><span style="color:#24292E;">(BiThrTree </span><span style="color:#E36209;">p</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(p </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">NULL</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 线索化左子树</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">InTheading</span><span style="color:#24292E;">(p-&gt;lchild);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果当前结点的左子树为空，则需要建立前驱线索</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">p-&gt;lchild){</span></span>
<span class="line"><span style="color:#24292E;">        p-&gt;LTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread;</span></span>
<span class="line"><span style="color:#24292E;">        p-&gt;lchild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pre;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果左子树不为空</span></span>
<span class="line"><span style="color:#24292E;">        p-&gt;LTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Link;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果前驱结点的右子树为空，则为前驱建立后继线索</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">pre-&gt;rchild){</span></span>
<span class="line"><span style="color:#24292E;">        pre-&gt;RTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread;</span></span>
<span class="line"><span style="color:#24292E;">        pre-&gt;rchild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">        pre-&gt;RTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Link;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span><span style="color:#6A737D;">   // pre向前挪一步</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">InTheading</span><span style="color:#24292E;">(p-&gt;rchild);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> * 中序遍历二叉树T，并将其全线索化为线索二叉树Thrt。</span></span>
<span class="line"><span style="color:#6A737D;"> * 注：这里的线索包括前驱线索与后继线索。</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#24292E;">Status </span><span style="color:#6F42C1;">InOrderThreading</span><span style="color:#24292E;">(BiThrTree</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#E36209;">Thrt</span><span style="color:#24292E;">, BiThrTree </span><span style="color:#E36209;">T</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 建立头结点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (BiThrTree) </span><span style="color:#6F42C1;">malloc</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">sizeof</span><span style="color:#24292E;">(BiThrNode));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!*</span><span style="color:#24292E;">Thrt) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">exit</span><span style="color:#24292E;">(OVERFLOW);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    (</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt)-&gt;data </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;</span><span style="color:#005CC5;">\\0</span><span style="color:#032F62;">&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    (</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt)-&gt;LTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Link;</span><span style="color:#6A737D;">       // 左孩子，需要指向二叉树的根结点</span></span>
<span class="line"><span style="color:#24292E;">    (</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt)-&gt;RTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread;</span><span style="color:#6A737D;">     // 右指针，需要指向中序序列最后一个元素，以便逆中序遍历线索二叉树</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    (</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt)-&gt;rchild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若二叉树为空，则左指针回指</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">T) {</span></span>
<span class="line"><span style="color:#24292E;">        (</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt)-&gt;lchild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        (</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt)-&gt;lchild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> T;</span><span style="color:#6A737D;">    // 指向二叉树头结点</span></span>
<span class="line"><span style="color:#24292E;">        pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt;</span><span style="color:#6A737D;">            // 记录前驱信息，初始化为线索二叉树头结点</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">InTheading</span><span style="color:#24292E;">(T);</span><span style="color:#6A737D;">          // 中序遍历，以进行中序线索化</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        pre-&gt;rchild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt;</span><span style="color:#6A737D;">    // 最后一个结点指回线索二叉树头结点</span></span>
<span class="line"><span style="color:#24292E;">        pre-&gt;RTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread;</span><span style="color:#6A737D;">     // 最后一个结点线索化</span></span>
<span class="line"><span style="color:#24292E;">        (</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Thrt)-&gt;rchild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pre;</span><span style="color:#6A737D;">  // 头结点指向最后一个结点，建立双向联系</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> OK;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="中序遍历中序全线索二叉树" tabindex="-1">中序遍历中序全线索二叉树 <a class="header-anchor" href="#中序遍历中序全线索二叉树" aria-label="Permalink to &quot;中序遍历中序全线索二叉树&quot;">​</a></h2><p><img src="`+s+`" alt="image-20231130104837172"></p><p>循环访问<code>—</code> <code>+</code> <code>a</code> 访问<code>a</code> ；<code>a</code>的右tag为线索，p指针<code>+</code>，访问<code>+</code> ,<code>+</code>的右tag为不是线索；访问右子树<code>-</code></p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> * 中序遍历中序全线索二叉树（非递归算法）。</span></span>
<span class="line"><span style="color:#6A737D;"> *</span></span>
<span class="line"><span style="color:#6A737D;"> * 注：该方法可以验证后继线索是否正确</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#E1E4E8;">Status </span><span style="color:#B392F0;">InOrderTraverse_Thr</span><span style="color:#E1E4E8;">(BiThrTree </span><span style="color:#FFAB70;">T</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">Status</span><span style="color:#E1E4E8;">(Visit)(TElemType)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    BiThrTree p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> T-&gt;lchild;</span><span style="color:#6A737D;">    // p指向二叉树根结点（不同于线索二叉树的头结点）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 空树或遍历结束时，p==T</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;">(p </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> T) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果存在左孩子，则持续向左访问</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;">(p-&gt;LTag </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Link) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p-&gt;lchild;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 访问左子树为空的结点（最左边）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">Visit</span><span style="color:#E1E4E8;">(p-&gt;data)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ERROR;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果存在后继线索（即没有右子树）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;">(p-&gt;RTag </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Thread </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> p-&gt;rchild </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> T) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p-&gt;rchild;</span><span style="color:#6A737D;">   // 将p指向其后继</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">Visit</span><span style="color:#E1E4E8;">(p-&gt;data);</span><span style="color:#6A737D;">  // 访问后继结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 访问右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">        p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p-&gt;rchild;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">printf</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#79B8FF;">\\n</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> OK;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> * 中序遍历中序全线索二叉树（非递归算法）。</span></span>
<span class="line"><span style="color:#6A737D;"> *</span></span>
<span class="line"><span style="color:#6A737D;"> * 注：该方法可以验证后继线索是否正确</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#24292E;">Status </span><span style="color:#6F42C1;">InOrderTraverse_Thr</span><span style="color:#24292E;">(BiThrTree </span><span style="color:#E36209;">T</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">Status</span><span style="color:#24292E;">(Visit)(TElemType)) {</span></span>
<span class="line"><span style="color:#24292E;">    BiThrTree p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> T-&gt;lchild;</span><span style="color:#6A737D;">    // p指向二叉树根结点（不同于线索二叉树的头结点）</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 空树或遍历结束时，p==T</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;">(p </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> T) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果存在左孩子，则持续向左访问</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;">(p-&gt;LTag </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> Link) {</span></span>
<span class="line"><span style="color:#24292E;">            p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p-&gt;lchild;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 访问左子树为空的结点（最左边）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">Visit</span><span style="color:#24292E;">(p-&gt;data)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ERROR;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果存在后继线索（即没有右子树）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;">(p-&gt;RTag </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> Thread </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> p-&gt;rchild </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> T) {</span></span>
<span class="line"><span style="color:#24292E;">            p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p-&gt;rchild;</span><span style="color:#6A737D;">   // 将p指向其后继</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">Visit</span><span style="color:#24292E;">(p-&gt;data);</span><span style="color:#6A737D;">  // 访问后继结点</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 访问右子树</span></span>
<span class="line"><span style="color:#24292E;">        p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p-&gt;rchild;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">printf</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;</span><span style="color:#005CC5;">\\n</span><span style="color:#032F62;">&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> OK;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div>`,24),t=[c];function r(E,y,i,A,F,d){return a(),p("div",null,t)}const h=n(e,[["render",r]]);export{T as __pageData,h as default};
